package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"math"

	"github.com/mamalovesyou/claimclam/graphql/gen/model"
	"github.com/mamalovesyou/claimclam/internal/logging"
	"github.com/mamalovesyou/claimclam/internal/podcasts"
	"github.com/mamalovesyou/claimclam/services/gateway/graph"
	"go.uber.org/zap"
)

// Podcasts is the resolver for the podcasts field.
func (r *queryResolver) Podcasts(ctx context.Context, search *string, title *string, category *string, page *int, limit *int) (*model.PodcastPage, error) {
	logger := logging.WithContext(ctx)
	logger.Info("Podcast query", zap.Intp("limit", limit), zap.Stringp("search", search), zap.Stringp("title", title), zap.Stringp("category", category), zap.Intp("page", page))
	params := &podcasts.ListPodcastsParams{
		Search:       search,
		Title:        title,
		CategoryName: category,
		Page:         page,
		Limit:        limit,
	}
	podcasts, err := r.podcastsClient.ListPodcasts(ctx, params)
	if err != nil {
		logger.Error("Podcast query failed", zap.Error(err))
		return nil, err
	}

	totalPages := int(math.Ceil(float64(podcasts.TotalCount) / float64(*limit)))
	return &model.PodcastPage{
		PageInfo: &model.PageInfo{
			CurrentPage: page,
			TotalPages:  &totalPages,
		},
		Items:      podcasts.Podcasts,
		TotalCount: &podcasts.TotalCount,
	}, nil
}

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
